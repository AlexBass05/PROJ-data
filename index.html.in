<!-- This file is the root of https://cdn.proj.org/ -->
<!-- Part of it is generated by the regenerate_index_html.py script -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>PROJ Datumgrid CDN</title>
<!--
<script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v6.1.1/build/ol.js"></script>
<link rel="stylesheet" href="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v6.1.1/css/ol.css">
-->
<script src="ol.js"></script>
<link rel="stylesheet" href="ol.css">
<!-- corresponding to https://github.com/rouault/geotiff.js/pull/new/cumulative_fixes -->
<script src="geotiff.bundle.min.js"></script>
<style>
    .map {
        width: 50%;
        height: 600px;
    }
    .ol-popup {
        position: absolute;
        background-color: white;
        -webkit-filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
        filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #cccccc;
        bottom: 12px;
        left: -50px;
        min-width: 280px;
    }
    .ol-popup:after, .ol-popup:before {
        top: 100%;
        border: solid transparent;
        content: " ";
        height: 0;
        width: 0;
        position: absolute;
        pointer-events: none;
        }
    .ol-popup:after {
        border-top-color: white;
        border-width: 10px;
        left: 48px;
        margin-left: -10px;
    }
    .ol-popup:before {
        border-top-color: #cccccc;
        border-width: 11px;
        left: 48px;
        margin-left: -11px;
    }
    .ol-popup-closer {
        text-decoration: none;
        position: absolute;
        top: 2px;
        right: 8px;
    }
    .ol-popup-closer:after {
        content: "âœ–";
    }
</style>
</head>

<body>

<h1>PROJ.org Datumgrid CDN</h1>
<p>
The s3://cdn.proj.org bucket is hosted by the
<a href="https://aws.amazon.com/opendata/public-datasets/">Amazon Public Datasets</a> program, and it
can be accessed via HTTP/S at <a href="https://cdn.proj.org">cdn.proj.org</a>. CDN services are
provided by the AWS Public Dataset team via <a href="https://aws.amazon.com/cloudfront/">CloudFront</a>.
</p>
<p>
The CDN contains <a href="https://www.cogeo.org/">Cloud Optimized GeoTIFF</a> datasets which are mirrored and
managed by the
<a href="https://github.com/OSGeo/proj-datumgrid-geotiff/">https://github.com/OSGeo/proj-datumgrid-geotiff/</a>
GitHub project.  Files in the CDN are designed to be used by <a href="https://proj.org">PROJ</a> 7 or later, but any software
project wishing to use the CDN for shifting support are encouraged to participate in the project and leverage the CDN.
</p>
<h2>Mirroring</h2>
<p>If you are able, you are encouraged to mirror the grids via AWS S3 command line: </p>
<pre>aws s3 sync s3://cdn.proj.org .</pre>

<p>If direct S3 access is not possible, you can also use <i>wget</i> to locally mirror
the data: </p>
<pre>wget --mirror https://cdn.proj.org/</pre>

<h2>Content</h2>
<div>
    <div id="map" class="map" style="float: left;"></div>
    <div id="details" style="height: 600px; overflow-y: scroll;">
        Click on the map to display the names of the files under the pointer,
        and get the values of the shift(s).
    </div>
    <div style="clear: both;"></div>
</div>
<div id="popup" class="ol-popup">
    <a href="#" id="popup-closer" class="ol-popup-closer"></a>
    <div id="popup-content"></div>
</div>
<script>
var vectorLayerJSON = new ol.layer.Vector({
  source: new ol.source.Vector({
    format: new ol.format.GeoJSON(),
    url: 'files.geojson'
    //url: "https://gist.githubusercontent.com/rouault/7c2f687e58b7e1e6a30c48f39d3d879e/raw/c68c647812ba23bf58e7986a158e65671326f4c3/files.geojson"
  }),
  style: new ol.style.Style({
    stroke : new ol.style.Stroke(
    {
        width : 1
    }),
    fill : new ol.style.Fill(
    {
        color :  'rgba(0, 0, 0, 0.01)'
    })
  })
});


/**
 * Elements that make up the popup.
 */
var container = document.getElementById('popup');
var content = document.getElementById('popup-content');
var closer = document.getElementById('popup-closer');
var details = document.getElementById('details');

/**
 * Create an overlay to anchor the popup to the map.
 */
var overlay = new ol.Overlay({
  element: container,
  autoPan: true,
  autoPanAnimation: {
    duration: 250
  }
});


/**
 * Add a click handler to hide the popup.
 * @return {boolean} Don't follow the href.
 */
closer.onclick = function() {
  overlay.setPosition(undefined);
  closer.blur();
  return false;
};


var map = new ol.Map({
  layers: [new ol.layer.Tile({source: new ol.source.OSM()}), vectorLayerJSON],
  renderer: 'canvas',
  target: 'map',
  overlays: [overlay],
  view: new ol.View({
    center: [0, 0],
    zoom: 0
  })
});


// Add an event handler for the map "singleclick" event
map.on('singleclick', function(evt) {
    var coordinate = evt.coordinate;
    let longlat = ol.proj.transform(coordinate, 'EPSG:3857', 'EPSG:4326');
    while( longlat[0] > 180 ) {
        longlat[0] -= 360;
    }
    while( longlat[0] < -180 ) {
        longlat[0] += 360;
    }

    //content_innerHTML = '';
    details_innerHTML = 'Latitude: ' + (longlat[1]).toFixed(8);
    details_innerHTML += '. Longitude: ' + (longlat[0]).toFixed(8);
    details_innerHTML += '.<br>Values displayed in their interpolation CRS, and at the closest node.'
    count = 0;
    requests = [];
    map.forEachFeatureAtPixel(evt.pixel, function(feature, layer) {
        var props = feature.getProperties();
        count ++;
        //content_innerHTML += '<p><a href="' + props.name + '">' + props.name + '</a></p>';
        details_innerHTML += '<hr>';
        details_innerHTML += '<p><a href="' + props.name + '">' + props.name + '</a>: '
        if( props.area_of_use ) {
            details_innerHTML += props.area_of_use + ', ';
        }
        details_innerHTML += props.source;
        details_innerHTML += ', ' + props.description;
        const div_id = 'value_' + count + '_' + coordinate;
        details_innerHTML += '<div id="' + div_id + '"><p>Loading in progress...</p></div>';
        details_innerHTML += '</p>';

        requests.push([async function(props, count) {
            //const url = "./" + props.source_id + "/" + props.name;
            const url = props.url;
            const tiff = await GeoTIFF.fromUrl(url);
            let best_image = -1;
            const imageCount = await tiff.getImageCount();
            for( let idx_image = 0; idx_image < imageCount; idx_image++ ) {
                const image = await tiff.getImage(idx_image);
                const width = image.getWidth();
                const height = image.getHeight();
                const origin = image.getOrigin();
                const resolution = image.getResolution();
                let origin_lon = origin[0];
                if( longlat[0] < origin_lon )
                    origin_lon -= 360;
                else if( longlat[0] > origin_lon + (width-1) * resolution[0] )
                    origin_lon += 360;
                const origin_lat = origin[1];
                let left = Math.round((longlat[0] - origin_lon) / resolution[0]);
                let top = Math.round((longlat[1] - origin_lat) / resolution[1]);
                let right = left + 1;
                let bottom = top + 1;
                if( left >= 0 && top >= 0 && right <= width && bottom <= height ) {
                    best_image = idx_image;
                }
            }

            if( best_image < 0 ) {
                document.getElementById(div_id).innerHTML = '<p>Out of grid</p>';
                return;
            }

            const first_image = await tiff.getImage(0);
            const md = first_image.getGDALMetadata();
            const image = await tiff.getImage(best_image);
            const width = image.getWidth();
            const height = image.getHeight();
            const origin = image.getOrigin();
            const resolution = image.getResolution();
            let origin_lon = origin[0];
            if( longlat[0] < origin_lon )
                origin_lon -= 360;
            else if( longlat[0] > origin_lon + (width-1) * resolution[0] )
                origin_lon += 360;
            const origin_lat = origin[1];
            let left = Math.round((longlat[0] - origin_lon) / resolution[0]);
            let top = Math.round((longlat[1] - origin_lat) / resolution[1]);
            let right = left + 1;
            let bottom = top + 1;
            if( left >= 0 && top >= 0 && right <= width && bottom <= height ) {
                const data = await image.readRasters({ window: [left, top, right, bottom] });
                valueHTML = ''
                for (let i = 0; i < data.length; ++i) {
                    const md_band = first_image.getGDALMetadata(i);
                    const scale = (md_band['SCALE'] != null) ? Number(md_band['SCALE']) : 1.0;
                    const offset = (md_band['OFFSET'] != null) ? Number(md_band['OFFSET']) : 0.0;
                    const unscaled_val = data[i][0];
                    const nodata = image.getGDALNoData();
                    const band_desc = (md_band['DESCRIPTION'] != null) ? md_band['DESCRIPTION'] : 'Band ' + (i+1);

                    if( nodata != null && unscaled_val == nodata ) {
                        if( i > 0 ) {
                            valueHTML += '<br>';
                        }
                        valueHTML += band_desc + ': nodata';
                    } else {
                        const unit = md_band['UNITTYPE'];
                        const scaled_val = unscaled_val * scale + offset;
                        if( (band_desc == 'latitude_offset_accuracy' || band_desc == 'longitude_offset_accuracy') && scaled_val <= 0 ) {
                            // nothing
                        }
                        else {
                            const precision = (unit && unit == "metre") ? 3 : 6;
                            if( i > 0 ) {
                                valueHTML += '<br>';
                            }
                            valueHTML += band_desc + ': ' + (scaled_val).toFixed(precision);
                            if( unit ) {
                                valueHTML += ' ' + unit;
                            }
                        }
                    }
                }
                document.getElementById(div_id).innerHTML = valueHTML;
            }

        }, props, count]);
    });
    details.innerHTML = details_innerHTML;

    for( let i = 0; i < requests.length; i++ ) {
        requests[i][0](requests[i][1], requests[i][2]);
    }
/*
    if( count >= 5 ) {
        content_innerHTML = '';
    }
    content.innerHTML = content_innerHTML;
    if (content_innerHTML != '') {
        overlay.setPosition(coordinate);
    } else {
        overlay.setPosition(undefined);
    }
*/
});

</script>

<p>The bucket contains the following files:</p>
<ul>
<li><a href="README.DATUMGRID">README.DATUMGRID</a></li>
${LINKS_WILL_BE_ADDED_HERE_BY_REGENERATE_INDEX_HTML}
</ul>
<p>
Total size of content: ${TOTAL_SIZE}
</p>

<h2>Logs</h2>
<p>Access logs to this resource are permanently deleted after one day, are not
mirrored or stored, and are not publicly available. If this policy is not
sufficient, users are encourage to mirror a local copy of the grid files and
access them directly.
</p>

<div style="text-align: center;">
<a href="https://aws.amazon.com/what-is-cloud-computing">
<img src="https://d0.awsstatic.com/logos/powered-by-aws.png" style="position: relative; top: 50%; transform: translateY(50%);" alt="Powered by AWS Cloud Computing">
</a>&nbsp;for use by&nbsp;
<a href="https://proj.org">
<img src="https://proj.org/_static/logo.png" style="position: relative; top: 50%; transform: translateY(50%);" alt="PROJ"></a>
</div>
</body>
</html>
